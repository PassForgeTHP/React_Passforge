/**
 * PassForge Crypto Service
 *
 * Encryption service using Web Crypto API to ensure
 * Zero-Knowledge security for user data.
 *
 * Technologies:
 * - PBKDF2-HMAC-SHA256 (600,000 iterations) for key derivation
 * - AES-256-GCM for authenticated encryption
 */

// ============================================================================
// 1. SALT GENERATION
// ============================================================================

/**
 * Generates a cryptographically secure salt of 32 bytes (256 bits).
 *
 * The salt is unique per user and prevents rainbow table attacks.
 * It is NOT secret and can be stored in plain text in the database.
 *
 * @returns {Uint8Array} 32-byte salt
 *
 * @example
 * const salt = generateSalt();
 * // salt = Uint8Array(32) [0x7a, 0x3f, 0x9e, ...]
 */
export function generateSalt() {
  return crypto.getRandomValues(new Uint8Array(32));
}

// ============================================================================
// 2. IV (INITIALIZATION VECTOR) GENERATION
// ============================================================================

/**
 * Generates an IV (Initialization Vector) of 12 bytes (96 bits) for AES-GCM.
 *
 * CRITICAL: A new IV must be generated for EVERY encryption operation.
 * Reusing an IV with the same key = TOTAL SECURITY BREACH.
 *
 * The IV is NOT secret and must be stored with the encrypted data.
 *
 * @returns {Uint8Array} 12-byte IV (NIST SP 800-38D recommendation)
 *
 * @example
 * const iv = generateIV();
 * // iv = Uint8Array(12) [0x4b, 0x7d, 0x3f, ...]
 */
export function generateIV() {
  return crypto.getRandomValues(new Uint8Array(12));
}

// ============================================================================
// 3. KEY DERIVATION (PBKDF2)
// ============================================================================

/**
 * Derives an AES-256 encryption key from a Master Password.
 *
 * Uses PBKDF2-HMAC-SHA256 with 600,000 iterations (OWASP 2024 recommendation).
 * The process takes ~150ms intentionally to slow down brute force attacks.
 *
 * Security:
 * - 600,000 iterations = slows down attackers by 600,000Ã—
 * - 1 billion attempts = 4.7 years (instead of 16 minutes)
 *
 * @param {string} password - User's Master Password
 * @param {Uint8Array} salt - Unique 32-byte salt
 * @returns {Promise<CryptoKey>} AES-256-GCM key (non-extractable)
 *
 * @example
 * const salt = generateSalt();
 * const key = await deriveKey("MyPassword123!", salt);
 * // key = CryptoKey { type: "secret", algorithm: "AES-GCM", ... }
 */
export async function deriveKey(password, salt) {
  // Convert password to ArrayBuffer
  const passwordBuffer = new TextEncoder().encode(password);

  // Import password as PBKDF2 key material
  const passwordKey = await crypto.subtle.importKey(
    'raw',
    passwordBuffer,
    'PBKDF2',
    false, // Non-extractable (security)
    ['deriveKey']
  );

  // Derive AES-256-GCM key with PBKDF2
  const key = await crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: 600000, // 600k iterations (OWASP 2024)
      hash: 'SHA-256'
    },
    passwordKey,
    {
      name: 'AES-GCM',
      length: 256 // 256 bits
    },
    false, // Non-extractable (cannot be exported)
    ['encrypt', 'decrypt']
  );

  return key;
}

// ============================================================================
// 4. ENCRYPTION (AES-256-GCM)
// ============================================================================

/**
 * Encrypts data with AES-256-GCM.
 *
 * AES-GCM provides:
 * - Confidentiality (AES-256 encryption)
 * - Integrity (128-bit authentication tag)
 *
 * A new IV is automatically generated for each encryption.
 * The authentication tag is included in the encrypted data (last 16 bytes).
 *
 * @param {string} data - Plaintext data to encrypt
 * @param {CryptoKey} key - AES-256-GCM key (generated by deriveKey)
 * @returns {Promise<{encrypted: ArrayBuffer, iv: Uint8Array}>} Encrypted data + IV
 *
 * @example
 * const key = await deriveKey("password", salt);
 * const { encrypted, iv } = await encryptData("My secret", key);
 * // encrypted = ArrayBuffer containing ciphertext + tag (128 bits)
 * // iv = Uint8Array(12) to be stored with encrypted
 */
export async function encryptData(data, key) {
  // CRITICAL: Generate a NEW IV for this encryption
  const iv = generateIV();

  // Convert data to ArrayBuffer
  const dataBuffer = new TextEncoder().encode(data);

  // Encrypt with AES-256-GCM
  const encrypted = await crypto.subtle.encrypt(
    {
      name: 'AES-GCM',
      iv: iv
      // tagLength: 128 bits (default, included in encrypted)
    },
    key,
    dataBuffer
  );

  // Return encrypted data + IV
  // Note: The authentication tag (128 bits) is already included in encrypted
  return {
    encrypted,
    iv
  };
}

// ============================================================================
// 5. DECRYPTION (AES-256-GCM)
// ============================================================================

/**
 * Decrypts AES-256-GCM data.
 *
 * Automatically verifies the authentication tag.
 * If the data has been modified or the key is incorrect,
 * an OperationError is thrown.
 *
 * @param {ArrayBuffer} encryptedData - Encrypted data (includes tag)
 * @param {CryptoKey} key - AES-256-GCM key (same as for encryption)
 * @param {Uint8Array} iv - IV used during encryption
 * @returns {Promise<string>} Decrypted plaintext data
 * @throws {DOMException} OperationError if:
 *   - Wrong key (incorrect Master Password)
 *   - Corrupted or modified data
 *   - Invalid authentication tag
 *
 * @example
 * try {
 *   const key = await deriveKey("password", salt);
 *   const decrypted = await decryptData(encrypted, key, iv);
 *   console.log(decrypted); // "My secret"
 * } catch (error) {
 *   console.error("Incorrect Master Password or corrupted data");
 * }
 */
export async function decryptData(encryptedData, key, iv) {
  // Decrypt with AES-256-GCM
  // Automatically verifies the authentication tag
  const decrypted = await crypto.subtle.decrypt(
    {
      name: 'AES-GCM',
      iv: iv
    },
    key,
    encryptedData // Includes ciphertext + tag (128 bits)
  );

  // Convert ArrayBuffer to string
  const plaintext = new TextDecoder().decode(decrypted);

  return plaintext;
}
